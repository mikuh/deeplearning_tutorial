# 理解均方误差、交叉熵、似然估计

简单的讲，在深度学习中，我们希望训练之后的模型对输入$x$的输出$a$尽可能的和真实标签$y$接近。

要比较两个值的大小之前的差异，最简单想法就是求比值或者求差的绝对值，如果是比值的话就是越接近于1两个数值越接近，相减求差绝对值的话，就是越接近于0越接近。

这里的最小化均方误差其实就是类似于求差值的方法，均方误差越小，两个值的差距就越小。这很容易想到，所以也容易理解，一般我们学习深度学习，第一个学的损失函数就是均方误差$C=(y-a)^x/2$, 其中$y$是期望输出，$a$是实际输出，下面同意使用这个定义。

但是随着学习的深入，我们会发现当使用sigmoid激活输出的时候，可能存在一个训练速度越来越慢的问题。因为我们求损失的偏导，会发现：


$$
\begin{eqnarray} 
  \frac{\partial C}{\partial w} & = & (a-y)\sigma'(z) x = a \sigma'(z) \\
  
  \frac{\partial C}{\partial b} & = & (a-y)\sigma'(z) = a \sigma'(z)
\end{eqnarray}
$$
它都和sigmoid函数的导数$\sigma'(z)$ 有关，再回想一下sigmoid的曲线

![](../images/i5.png)

当$\sigma$的值趋近于1或者0时，曲线的会变得十分平缓，也就是偏导会很小，于是梯度下降每次的移动也会很微小，于是就造成了训练难以继续下去。

为了解决这个问题，然后我们引入了交叉熵损失：
$$
C=- \frac{1}{n}\sum_x[y\ln a+(1-y)ln(1-a)]
$$
交叉熵这个词乍一听还真有些不明觉厉，不过从形式上来看，它确实达到了损失函数的要求，并且也解决了均方误差训练速度减慢的问题。

观察上面的表达式，涉及$a$的单项都是负的，而前面又乘了个负数，因此$C>0$,并且，我们可以假设某个输入$x$对应的$y$是0，而且 $a \approx 0$，那么 $C$ 就会非常小，反之$a$如果接近1，那么$C$会变得很大，当然假设$y$是1的时候也能达到这种效果，这些都表明了交叉熵作为损失函数的特性。而它又是怎么解决梯度过小而导致的训练变慢问题的呢？

让我们来计算一下它对于权重$w$的偏导，并且把$a = \sigma(z)$代进去：
$$
\begin{eqnarray}
  \frac{\partial C}{\partial w_j} & = & -\frac{1}{n} \sum_x \left(
    \frac{y }{\sigma(z)} -\frac{(1-y)}{1-\sigma(z)} \right)
  \frac{\partial \sigma}{\partial w_j} \\
 & = & -\frac{1}{n} \sum_x \left( 
    \frac{y}{\sigma(z)} 
    -\frac{(1-y)}{1-\sigma(z)} \right)\sigma'(z) x_j
\end{eqnarray}
$$
而基于sigmoid函数的性质，我们知道$\sigma'(z) = \sigma(z)(1-\sigma(z))$ ,带入上面的方程，发现$\sigma'(z)$ 恰好被抵消了：
$$
\begin{eqnarray} 
  \frac{\partial C}{\partial w_j} =  \frac{1}{n} \sum_x x_j(\sigma(z)-y)
\end{eqnarray}
$$
完美避免了因为$\sigma'(z)$变小而引起的训练慢的问题，并且，从上面的等式中，我们也可以很容易的看出当误差越大时，偏导也会越大，即学的越快，这跟我们人类学习东西的直觉是一致的，发现的错误越大，学到的东西越多~

当然，这个交叉熵并不是凭空想出来的，顾名思义，我们也许会猜出的一二，它应该和信息论有关，说的没错，接下来我们就去信息论那边找找线索。



信息论的基本想法就是：一个不太可能的事情发生了，要比一个非常可能发生的事情发生，提供更多的信息。

比如，有个消息说：“今天早上太阳升起”，信息量是如此之少，以至于不值一提；但是如果另一个消息是：“今天早上会有日食”，这样信息量就丰富了。于是，可以用这一基本思想来量化信息。特别是：

- 非常可能发生的事件信息量比较少，并且极端情况下，确保能发生的事件应该没有信息量。
- 较不可能发生的事情具有更高的信息量。
- 独立事件应该具有增量的信息。例如，投掷的硬币两次正面朝上传递的信息量，应该是投掷一次硬币正面朝上的信息量的两倍。

为了满足上述3个性质，我们定义一个事件$x=x$的自信息（self-information）为：
$$
I(x) = -\ln P(x)
$$
其中$ln$是底数位$e$的自然对数，因此这里$I(x)$的单位是奈特。

当$x$ 是连续的，我们使用类似的关于信息的定义，但有些源于离散形式的性质就丢失了。例如一个具有单位密度的事件的信息量为0，但是不能保证它一定发生。

自信息值处理单个的输出。我们可以用香农熵（shannon entropy）来对整个概率分布中的不确定性总量进行量化：
$$
H(x)=E_{x -P}[I(x)]=-E_{x-P}[\ln P(x)]
$$
换言之，一个分布的香农熵指遵循这个分布的事件所产生的期望信息总量。

如果对于同一个随机变量$x$有两个单独的概率分布$P(x)$和Q(x),可以使用KL散度来衡量着两个分布的差异：

 
$$
D_{KL}(P||Q) =E_{x-P}[\ln \frac{P(x)}{Q(x)}] = E_{x-P}[\ln P(x) - ln Q(x)]=-H(P)+H(Q)
$$
那这些要怎么和前面的损失函数联系起来呢？

回想一下最简单的MNIST手写数字识别的神经网络，输出神经元一共有10个，分别代表0~10，然后我们取了值最大的那个作为模型的解。于是，简单的类比，我们可以把10个神经元的输出，看成是模型猜测的某个输入样本$x$

它是不是某个数字的概率，而同样的标签也代表了是否是某个数字的概率。这样，我们就有了关于随机变量$x$ 的两个独立的概率分布，一个是模型的，另一个是训练数据本身的，而我们所希望的，就是让模型的概率分布接近于真实的训练数据的概率分布，为了衡量他们之间的差异，刚好$KL$散度就用上了。

也就是说要让模型和真实情况最接近，那么就要最小化**KL散度**，而显然训练数据的分布$H(P)$是固定的，并不会受到模型参数的影响，于是我们把左边的$-H(p)$消掉，就得到了**交叉熵**
$$
H(P,Q) = -E_{x-p}lnQ(x)
$$
最小化交叉熵，就是最小化KL散度，也就是最小化模型和真实之间的差距。

正如前面所说的，我们模型的输出$a$ 代表了是对应标签（也就是$y$）的概率，而$1-a$ 就是不是对应标签（也就是$1-y$）的概率，于是单个样本的香浓熵$H(x) = -[ylna+(1-y)ln(1-a)]$,然后放到所有的样本上再取平均，就得到了最开始所学的交叉熵损失函数：
$$
C=- \frac{1}{n}\sum_x[y\ln a+(1-y)ln(1-a)]
$$
哈，总算知道这个鬼公式是怎么来的了吧，它并不是凭空想出来的。不过，实际上我们也可以通过想办法消除$\sigma'(z)$ 这项的过程，来构造出交叉熵这个形式的函数。为了简单起见，我们从$  \frac{\partial C}{\partial b}$ 入手，想办法让它满足
$$
\frac{\partial C}{\partial b}  =  (a-y)\sigma'(z) = a-y
$$
既然是$\sigma'(z)$ 引起的训练速度慢，那么我们就想办法把它消掉。根据链式法则，于是有
$$
\begin{eqnarray}
  \frac{\partial C}{\partial b} = \frac{\partial C}{\partial a} 
  \sigma'(z)
\end{eqnarray}
$$
而$\sigma'(z) = \sigma(z)(1-\sigma(z)) = a(1-a)$ ,于是
$$

  \frac{\partial C}{\partial b} = \frac{\partial C}{\partial a} 
  a(1-a)
$$
我们让它等于$a-y$,便有了
$$
\begin{eqnarray}
  \frac{\partial C}{\partial a} = \frac{a-y}{a(1-a)}
\end{eqnarray}
$$
然后将上面的式子对$a$积分,当当当，交叉熵形式的公式出来啦：
$$
\begin{eqnarray}
  C = -[y \ln a + (1-y) \ln (1-a)]+ {\rm constant}\end{eqnarray}
$$
就是这么奇妙，这也进一步说明了交叉熵可以作为损失函数，并弥补了均方误差不足的原因~~~

接下来，我们再来说一下似然估计，个人觉得，最大似然估计才是我们模型训练的本质。

我们先来介绍一下似然函数(**如果你已经了解似然函数，可以跳过这一块介绍**)，它是一种关于统计模型中的参数的函数，你可以把它理解为条件概率的逆运算。

条件概率对大多数人而言是非常好理解并且自然的，但是它的逆反，往往会让人感觉有些难受，这需要一点时间来习惯这种思维，一旦习惯了，你也会觉得似然函数也是自然而然的。这是初学者常见的困惑，就像很多程序员刚开始接触递归的时候，可能会很难受，很反人类，但是一旦了解它了，就会变得爱不释手，觉得这才是人类该有的思维。总之，我觉得似然函数在机器学习里面至关重要，你需要花一点时间去理解它，先从我们最熟悉的思维入手。

大家都知道概率，是用于在已知一些参数的情况下，预测接下来在观测上所得到的结果；而似然性，恰好相反，用于在已知某些观测所得到的结果时，对有关事物之性质的参数进行估值。而机器学习不正是通过已经观测到的结果即训练数据，来对事物性质的参数进行估计，即得到相应的权重和偏差的模型。

在已知某个参数$B$时，事件$A$会发生的概率：


$$
P(A|B) = \frac {P(A,B)}{P(B)}
$$
根据贝叶斯定理，有
$$
P（B|A）= \frac{P(A|B)P(B)}{P(A)}
$$
因此，我们可以反过来构造表示似然性的方法：已知事件$A$发生，运用似然函数$L(B|A)$ ,来估计参数$B$的可能性。形式上看，似然函数也是一种条件概率函数，只不过我们关注点由概率到结果变成了由结果到概率，
$$
b \to P(A|B=b)
$$
注意到这里并不要求似然函数满足归一性：$\sum_{b \in B}P(A|B=b)=1$ ,一个似然函数乘以一个正的常数之后仍然是似然函数。对所有$\alpha$都可以有似然函数：
$$
L(b|A)=\alpha P(A|B=b)
$$
举个最简单的抛硬币的例子来更加具象化的理解似然函数（其实是维基上的例子...）

考虑投掷一枚硬币的实验。通常来说，已知掷出一枚“公平的硬币”（正面朝上和反面朝上的概率都为0.5）, 即正面(Head)朝上的概率为$P(H) = 0.5$，便可以知道投掷若干次后出现各种结果的可能性。

比如说，投两次都是正面朝上的概率是0.25。用条件概率表示，就是：
$$
P(HH|p_H=0.5)=0.5^2=0.25
$$
如果一个硬币的质量分布不够均匀, 那么它可能是一枚"非公平的硬币"

在统计学中，我们关心的是在**已知一系列投掷的结果时，关于硬币投掷时正面朝上的可能性的信息**。

我们可以建立一个统计模型：假设硬币投出时会有$p_H$ 的概率正面朝上，自然会有$1-p_H$ 的概率反面朝上。

这时，通过观察已经发生的两次投掷，条件概率可以改写成似然函数：
$$
L(p_H|HH) = P(HH|p_H)
$$
也就是说，如果我们取$p_H=0.5$的话，似然函数的值就是0.25。不过注意，这个反过来是不成立的，不能根据似然性是0.25反推出$p_H=0.5$

那么，如果我们取$p_H=0.6$的话，似然函数的值就变成0.36了，emm...而且还是变大了...

这说明，如果参数$p_H$取0.6的话，更有希望观察到两次正面朝上的结果，即参数$p_H=0.6$ 比$0.5$ 更有说服力，更合理。

总之，**似然函数的重要性不是它的具体取值，而是当参数变化时函数到底变小还是变大。**

对同一个似然函数，其所代表的模型中，某项参数值具有多种可能，但如果存在一个参数值，使得它的函数值达到**最大**的话，那么这个值就是该项参数最为“合理”的参数值。这便是我们稍后要重点说的**最大似然估计**。

在这个例子中，似然函数等于：
$$
L(p_H|HH) = P(HH|p_H=\theta)=\theta^2, ~~~as ~\theta \in  [0, 1]
$$
显然，如果取$p_H=1$ 是最能看到两次都为正面的结果的。



接下来，我们要把最大似然估计用到我们模型的学习中。

考虑到我们有一组真实的样本数据集$X={x_1, x_2,...,x_n}$ ，那么它们应该是独立的由一个位置的真实数据分布$P_{data}(x)$生成的。而假设我们的模型$p_{model}(x;\theta)$ 是由一个由$\theta$ （也就是一堆权重$w$和偏差$b$）确定的相同空间上的概率分布，那么对$\theta$ 的最大似然估计可以写成
$$
argmax L(p_{model}|X) = argmaxP(X|p_{model}(x;\theta))=argmax \prod_{x \in X}p_{model}(x;\theta)
$$
多个概率乘积会因为很多原因不方便计算，比如计算的时候会发生数值太小而溢出的情况，于是我们就对其取对数，因为单调性并不会发生改变，所以最大似然估计就等价于
$$
argmax lnL=argmax \sum_{x \in X}lnp_{model}(x;\theta)
$$
观察上面的等式，我们发现这个值跟样本数量有关，样本越多值越小，于是我们把它缩放一下，除以样本数量就变成了训练数据经验分布$p'_{data}$ 相关的期望表示
$$
argmax lnL=argmax  E_{x-p'_{data}}lnp_{model}(x;\theta)
$$
基于直觉（当然也可以证明，证明过程就留给写书的人吧orz...），就是当$p_{model}$ 和训练集上的经验分布$p'_{data}$ 之间的差异最小时，似然函数取得最大值。而他们之前的差异可以通过KL散度来衡量，带入前面KL散度的公式，于是就有了
$$
D_{KL}(p'_{data}||p_{model}) =E_{x-p'_{data}}[lnp'_{data}(x)-lnp_{model}(x;\theta)]
$$
而经验分布显然是基于训练数据固定的，然后最小化KL散度又变成了最小化两个分布之间的交叉熵，也就是负对数似然...

然后咱从最大似然估计出发又到最小化交叉熵了~~~真是万变不离其宗呐...其本质可以说都是让模型去拟合训练数据，只是方法有所不同罢了。

实际上，任何一个由负对数似然组成的损失都是定义在训练集上的经验分布和定义在模型上的概率分布之间的交叉熵。例如，**均方误差就是经验分布和高斯模型之间的交叉熵**。

什么..原来均方误差也是交...交叉熵......

说的没错,要不然让我们来推导一下

实际上,我们只要把上面的$p_{model}$ 变成一个不知道$\mu, \sigma$的高斯分布函数作为咱的似然函数：
$$
f(x|\mu,\sigma^2)=\frac{1}{\sqrt{}2\pi\sigma^2}e^{-\frac{(x-\mu)^2}{2\sigma^2}}
$$
然后还是把最大化这个函数变成最大化它的对数，然后分别对$\mu$ 和$\sigma$ 求偏导，让其偏导等于0，求出方程的解便是其极值。

![\begin{matrix}0 & = & \frac{\partial}{\partial \mu} \log \left( \left( \frac{1}{2\pi\sigma^2} \right)^\frac{n}{2} e^{-\frac{ \sum_{i=1}^{n}(x_i-\bar{x})^2+n(\bar{x}-\mu)^2}{2\sigma^2}} \right) \\  & = & \frac{\partial}{\partial \mu} \left( \log\left( \frac{1}{2\pi\sigma^2} \right)^\frac{n}{2} - \frac{ \sum_{i=1}^{n}(x_i-\bar{x})^2+n(\bar{x}-\mu)^2}{2\sigma^2} \right) \\  & = & 0 - \frac{-2n(\bar{x}-\mu)}{2\sigma^2} \\\end{matrix}](https://wikimedia.org/api/rest_v1/media/math/render/svg/855129e47348f3be56a146ba0e40496238cbacff)

这个方程的解是![\widehat{\mu} = \bar{x} = \sum^{n}_{i=1}x_i/n ](https://wikimedia.org/api/rest_v1/media/math/render/svg/a9183985ee75ecefa81c0c5b1f1d9985d28c402e).这的确是这个函数的最大值，因为它是{\displaystyle \mu }![\mu ](https://wikimedia.org/api/rest_v1/media/math/render/svg/9fd47b2a39f7a7856952afec1f1db72c67af6161)里头惟一的一阶导数等于零的点并且二阶导数严格小于零。

同理，我们对![\sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/59f59b7c3e6fdb1d0365a494b81fb9a696138c36)求导，并使其为零。


这个方程的解是![\widehat{\sigma}^2 = \sum_{i=1}^n(x_i-\widehat{\mu})^2/n](https://wikimedia.org/api/rest_v1/media/math/render/svg/84906a5b7a1190147f2af12883736b8518a56141).

因此，其关于![\theta=(\mu,\sigma^2)](https://wikimedia.org/api/rest_v1/media/math/render/svg/e8a76220bd34d7301e2c066e4cb89b1afaf88294)的最大似然估计为：

![\widehat{\theta}=(\widehat{\mu},\widehat{\sigma}^2) = (\bar{x},\sum_{i=1}^n(x_i-\bar{x})^2/n)](https://wikimedia.org/api/rest_v1/media/math/render/svg/6bc684bcdee9037b9dd8fc0bbae40054fc47cba6)

然后这玩意不就是均方误差吗orz....

